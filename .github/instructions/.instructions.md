---
applyTo: ecommerce/*
---
# GitHub Copilot Instructions

## Project Overview
This is a **Symfony 7.4** e-commerce application. Follow these guidelines when generating code suggestions.

### Docker Environment
- **Always run Symfony commands inside the PHP Docker container**
- Use `docker compose exec -u www-data php` prefix for all Symfony console commands
- Example: `docker compose exec -u www-data php bash -c "php bin/console make:entity"`
- Never run Symfony commands directly on the host machine

#### Accessing PHP Container Shell
```bash
make shell
```

Or directly:
```bash
docker compose exec -u www-data php bash
```

#### Running Symfony Console Commands
Always execute Symfony console commands inside the PHP container:
```bash
# First, enter the container
make shell

# Then run Symfony commands
php bin/console make:entity
php bin/console make:crud
php bin/console doctrine:migrations:migrate
# etc.
```

#### Running Composer Commands
Execute Composer commands inside the PHP container:
```bash
# First, enter the container
make shell

# Then run Composer commands
composer install
composer require package-name
composer update
# etc.
```

#### Quick Docker Command Reference
```bash
# Start containers
make up

# Stop containers
make down

# View logs
make logs

# Restart containers
make restart

# Build containers
make build

# Access shell
make shell
```

#### Development Workflow
1. Start the Docker environment: `make up`
2. Enter the PHP container: `make shell`
3. Run your commands inside the container
4. Exit the container: `exit`
5. Stop the environment when done: `make down`

### SVG Icons
- **Never use inline SVG code in Twig templates**
- All SVG icons must be stored as external files in `public/img/icons/`
- Use the Twig `svg()` function to include icons: `{{ svg('img/icons/icon-name.svg', {class: 'icon'}) }}`
- Common available icons:
  - `plus.svg` - Add/Create actions
  - `eye.svg` - View/Show actions
  - `pencil.svg` - Edit actions
  - `trash.svg` - Delete actions
  - `check.svg` - Save/Confirm actions
  - `x-circle.svg` - Cancel actions
  - `arrow-left.svg` - Back/Return navigation
  - `dashboard.svg` - Dashboard navigation
  - `logout.svg` - Logout action
  - `category.svg` - Category navigation
  - `products.svg` - Products navigation
- When creating new templates, always use external SVG files instead of inline SVG markup

## Important Project Rules

### Documentation
- **NEVER create summary or implementation documentation files** (e.g., SUMMARY.md, IMPLEMENTATION.md, CHECKLIST.md, etc.) unless explicitly requested by the user
- Only create technical documentation when specifically asked
- Focus on code implementation, not documentation files

### Administration Scoping
- **Always scope administration features under `/admin` path** for routes
- **Always use `Admin` or `Administration` namespace** for admin-related code
- Examples:
  - Routes: `/admin/login`, `/admin/dashboard`, `/admin/products`
  - Namespaces: `Wsei\Ecommerce\Controller\Admin`, `Wsei\Ecommerce\Service\Administration`
  - Templates: `templates/admin/`, `templates/admin/security/`
  - CSS: `public/css/admin/`
  - Providers: `admin_user_provider` not `app_user_provider`
- Keep admin functionality clearly separated from public-facing features

## Symfony-Specific Guidelines

### Framework Conventions
- Follow Symfony best practices and conventions
- Use Symfony's dependency injection container
- Leverage Symfony components (Form, Validator, Security, etc.)
- Use attributes for routing, validation, and ORM mapping
- Follow the Symfony directory structure

### Controllers
- Extend `AbstractController`
- Use constructor injection for dependencies
- Return `Response` objects from controller actions
- Use route attributes: `#[Route('/path', name: 'route_name')]`

### Services
- Auto-configure services in `services.yaml`
- Use constructor injection
- Tag services when needed
- Keep services focused on single responsibility

### Doctrine ORM
- Use attributes for entity mapping
- Define repositories as services
- Use QueryBuilder for complex queries
- Implement custom repository methods

### Forms
- Create FormType classes for forms
- Use form themes for consistent styling
- Implement CSRF protection (enabled by default)

## Coding Standards

### PHP
- Use PHP 8.0+ features where applicable
- Follow PSR-12 coding standards
- Use strict types: `declare(strict_types=1);`
- Prefer type hints for parameters and return types
- Use meaningful variable and function names
- Follow camelCase for methods and variables, PascalCase for classes

### Code Organization
- Keep controllers thin, move business logic to services
- Use dependency injection over static calls
- Implement repository pattern for data access
- Separate concerns: controllers, models, services, repositories

### Security
- Always sanitize user input
- Use prepared statements for database queries
- Implement CSRF protection for forms
- Hash passwords using `password_hash()` with bcrypt
- Validate and escape output to prevent XSS
- Use environment variables for sensitive configuration

### Database
- Use PDO for database connections
- Prefer migrations for schema changes
- Index foreign keys and frequently queried columns
- Use transactions for related operations
- Follow naming conventions: snake_case for tables and columns

### Frontend
- Keep JavaScript modular and maintainable
- Use modern ES6+ syntax
- Implement progressive enhancement
- Ensure responsive design
- Follow accessibility best practices (ARIA labels, semantic HTML)

### Comments and Documentation
- Write PHPDoc blocks for classes and methods
- Comment complex business logic
- Keep comments up-to-date with code changes
- Document API endpoints and their parameters

## Best Practices

### Error Handling
- Use try-catch blocks for expected exceptions
- Log errors appropriately
- Show user-friendly error messages
- Never expose sensitive information in errors

### Performance
- Implement caching where appropriate
- Optimize database queries (avoid N+1 problems)
- Lazy load resources when possible
- Minimize database calls

### Testing
- Write unit tests for business logic
- Test edge cases and error conditions
- Use meaningful test names that describe behavior

## File Structure
- Controllers: `/src/Controller/`
- Entities: `/src/Entity/`
- Forms: `/src/Form/`
- Repositories: `/src/Repository/`
- Services: `/src/Service/`
- Templates: `/templates/`
- Public assets: `/public/`
- Configuration: `/config/`
- Migrations: `/migrations/`

## Common Patterns

### Controller Example
```php
#[Route('/product')]
class ProductController extends AbstractController {
    public function __construct(
        private ProductService $productService
    ) {}
    
    #[Route('/{id}', name: 'product_show', methods: ['GET'])]
    public function show(int $id): Response {
        $product = $this->productService->findById($id);
        
        return $this->render('product/show.html.twig', [
            'product' => $product,
        ]);
    }
}
```

### Entity Example
```php
#[ORM\Entity(repositoryClass: ProductRepository::class)]
class Product {
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;
    
    #[ORM\Column(length: 255)]
    private ?string $name = null;
}
```

### Service Example
```php
class ProductService {
    public function __construct(
        private ProductRepository $repository
    ) {}
    
    public function findById(int $id): ?Product {
        return $this->repository->find($id);
    }
}
```

## API Authentication

### Overview
The e-commerce application provides a token-based API authentication system for customer-facing endpoints. All API routes are scoped under `/ecommerce/api/v1/` prefix.

### Authentication Flow

#### Login
**Endpoint:** `POST /ecommerce/api/v1/customer/login`

**Request Body (JSON):**
```json
{
  "email": "customer@example.com",
  "password": "password123"
}
```

**Success Response (200 OK):**
```json
{
  "token": "Abc123XyZ...48characters...ABC",
  "expiresAt": "2024-12-02 15:30:00"
}
```

**Error Response (401 Unauthorized):**
```json
{
  "error": "Unauthorized",
  "message": "Invalid credentials"
}
```

#### Logout
**Endpoint:** `POST /ecommerce/api/v1/customer/logout`

**Headers:**
```
wsei-ecommerce-token: Abc123XyZ...48characters...ABC
```

**Success Response (200 OK):**
```json
{
  "success": true
}
```

### Token Details
- **Format:** 48-character alphanumeric string (A-Za-z0-9)
- **Expiration:** 1 hour from creation/last login
- **Behavior:** Re-login extends existing token expiration (no new token created)
- **Limitation:** One active token per customer (one-to-one relationship)
- **Lifecycle:** Token is automatically deleted when customer is deleted

### Protected Endpoints
By default, all endpoints under `/ecommerce/api/v1/` require authentication via the `wsei-ecommerce-token` header.

**Request Headers:**
```
Content-Type: application/json
wsei-ecommerce-token: Abc123XyZ...48characters...ABC
```

**401 Error Response (Invalid/Missing Token):**
```json
{
  "error": "Unauthorized",
  "message": "Invalid or expired token"
}
```

### Public Endpoints
To mark an endpoint as publicly accessible (no token required), use the `#[PublicAccess]` attribute:

```php
use Wsei\Ecommerce\Attribute\PublicAccess;

#[PublicAccess]
#[Route('/some-public-endpoint', methods: ['POST'])]
public function publicAction(): JsonResponse
{
    // No authentication required
    return new JsonResponse(['message' => 'Public access']);
}
```

### Customer Auto-Injection
Authenticated endpoints can automatically inject the `Customer` entity into controller parameters:

```php
use Wsei\Ecommerce\Entity\Admin\Customer;

#[Route('/profile', name: 'ecommerce_api.customer.profile', methods: ['GET'])]
public function getProfile(Customer $customer): JsonResponse
{
    return new JsonResponse([
        'email' => $customer->getEmail(),
        'firstName' => $customer->getFirstName(),
        'lastName' => $customer->getLastName(),
    ]);
}
```

The `Customer` parameter is automatically resolved from the authenticated token. No manual token validation needed.

### Controller Example
```php
namespace Wsei\Ecommerce\Controller\EcommerceApi\V1\Customer;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Routing\Attribute\Route;
use Wsei\Ecommerce\Attribute\PublicAccess;
use Wsei\Ecommerce\Entity\Admin\Customer;

#[Route('/ecommerce/api/v1/customer')]
class CustomerProfileController extends AbstractController
{
    // Public endpoint - no authentication required
    #[PublicAccess]
    #[Route('/check', methods: ['GET'])]
    public function check(): JsonResponse
    {
        return new JsonResponse(['status' => 'API is running']);
    }
    
    // Protected endpoint - requires wsei-ecommerce-token header
    #[Route('/profile', methods: ['GET'])]
    public function profile(Customer $customer): JsonResponse
    {
        return new JsonResponse([
            'id' => $customer->getId(),
            'email' => $customer->getEmail(),
            'fullName' => $customer->getFullName(),
        ]);
    }
    
    // Protected endpoint with business logic
    #[Route('/addresses', methods: ['GET'])]
    public function addresses(Customer $customer): JsonResponse
    {
        $addresses = $customer->getAddresses()->map(function ($address) {
            return [
                'id' => $address->getId(),
                'street' => $address->getStreet(),
                'city' => $address->getCity(),
                'postalCode' => $address->getPostalCode(),
            ];
        })->toArray();
        
        return new JsonResponse(['addresses' => $addresses]);
    }
}
```

### API Controller Namespace
All API controllers should be placed in the namespace:
```
Wsei\Ecommerce\Controller\EcommerceApi\V1
```

For customer-specific endpoints:
```
Wsei\Ecommerce\Controller\EcommerceApi\V1\Customer
```

### Token Generation
Tokens are generated using the `ApiTokenHelper` utility class:

```php
use Wsei\Ecommerce\Utility\ApiTokenHelper;

$token = ApiTokenHelper::generate(); // Returns 48-char alphanumeric string
```

### Best Practices
- Always return JSON responses for API endpoints
- Use appropriate HTTP status codes (200, 401, 400, 404, etc.)
- Validate request data before processing
- Use `#[PublicAccess]` attribute only for truly public endpoints (login, registration, etc.)
- Type-hint `Customer` parameter to automatically inject authenticated customer
- All API responses should follow consistent JSON structure
- Handle errors gracefully with descriptive error messages

## Avoid
- Global variables
- Superglobal arrays ($_GET, $_POST) in business logic
- SQL injection vulnerabilities
- Hardcoded credentials
- Mixing HTML and PHP logic excessively
- Using deprecated PHP functions
- Hardcoding routes instead of using `path()` or `url()` functions
- Bypassing Symfony's service container
